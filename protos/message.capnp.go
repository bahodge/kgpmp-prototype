// Code generated by capnpc-go. DO NOT EDIT.

package protos

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

// standard kobold message for transfering info between clients and nodes
type KoboldMessage capnp.Struct

// KoboldMessage_TypeID is the unique identifier for the type KoboldMessage.
const KoboldMessage_TypeID = 0xa99b87f2a92d7eed

func NewKoboldMessage(s *capnp.Segment) (KoboldMessage, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return KoboldMessage(st), err
}

func NewRootKoboldMessage(s *capnp.Segment) (KoboldMessage, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4})
	return KoboldMessage(st), err
}

func ReadRootKoboldMessage(msg *capnp.Message) (KoboldMessage, error) {
	root, err := msg.Root()
	return KoboldMessage(root.Struct()), err
}

func (s KoboldMessage) String() string {
	str, _ := text.Marshal(0xa99b87f2a92d7eed, capnp.Struct(s))
	return str
}

func (s KoboldMessage) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (KoboldMessage) DecodeFromPtr(p capnp.Ptr) KoboldMessage {
	return KoboldMessage(capnp.Struct{}.DecodeFromPtr(p))
}

func (s KoboldMessage) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s KoboldMessage) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s KoboldMessage) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s KoboldMessage) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s KoboldMessage) Id() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s KoboldMessage) HasId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s KoboldMessage) IdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s KoboldMessage) SetId(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s KoboldMessage) Topic() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s KoboldMessage) HasTopic() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s KoboldMessage) TopicBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s KoboldMessage) SetTopic(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s KoboldMessage) TxId() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s KoboldMessage) HasTxId() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s KoboldMessage) TxIdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s KoboldMessage) SetTxId(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

func (s KoboldMessage) Content() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return []byte(p.Data()), err
}

func (s KoboldMessage) HasContent() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s KoboldMessage) SetContent(v []byte) error {
	return capnp.Struct(s).SetData(3, v)
}

// KoboldMessage_List is a list of KoboldMessage.
type KoboldMessage_List = capnp.StructList[KoboldMessage]

// NewKoboldMessage creates a new list of KoboldMessage.
func NewKoboldMessage_List(s *capnp.Segment, sz int32) (KoboldMessage_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 4}, sz)
	return capnp.StructList[KoboldMessage](l), err
}

// KoboldMessage_Future is a wrapper for a KoboldMessage promised by a client call.
type KoboldMessage_Future struct{ *capnp.Future }

func (f KoboldMessage_Future) Struct() (KoboldMessage, error) {
	p, err := f.Future.Ptr()
	return KoboldMessage(p.Struct()), err
}

const schema_e945d32308a30635 = "x\xda<\xcc1K#A\x00\x05\xe0\xf7f6\xc9\x15" +
	"\x09\x97%9\xeeH\x93\x81\xeb\x0e\xee\xce\x08\x82\xa4\xd1" +
	"\x08\x16\"\x82\xd3\x8b\xb8\xd9\x9d$\x8b\xc9\xcc\xb2;\xa0" +
	"\x95\x96\x82\xad\xa5\x82\x85U~\x84\xa5\xbf@\xf0/\x88" +
	"\x85\x85\xfe\x81\x95(Z\xbe\xef\xf1^\xf3j=\xe85" +
	"~\x0a\x08\xfd\xabR-\x9fO\xfe\xce_\xcf.\xe7\x08" +
	"\x7f\xb0\\\xa9\xde|\xfb}\xbf\xf9\x84JP\x03z/" +
	"\x1d\xb6\xc8Z\x8b\xec\xb6\x06|\xc4j\x99\xe5\xce\xbb\xe2" +
	"\xffL\x9a\xa2\x88\xc6\xe6_\x1ce6\xebo\xbb\xa1\x9b" +
	"&;\x0b\x93c\xb3K\xea\x80\xa2\xdc\xbf\xb8\xd6\xb7\x0f" +
	"\xe7w\xd0\x81\xe0`\x89\xac\x03=\xf6EY\xf8\xc8&" +
	"Q\x9e\xd4\xd4\xe1\xfbP\xcd>\xde\xd4\xc8\xe5\xca\xe7\x91" +
	"-F&O\xedX\xa5v\xe4\xd4\xd0\xf8#c\xac\x8a" +
	"\xa7\xa9\xb1\xbeP\x91M\xd6\x94u\x89)\x00\xdd\x94\x01" +
	"\x10\x10\x08\xa3\x0e\xa0\xf7$\xf5D0$\xdb\\\xa0Y" +
	"\x06\xf4\x81\xa4\x9e\x0a\x86B\xb4)\x800\xfd\x03\xe8D" +
	"Rg\x82\xa1\x94mJ \x9cm\x00z\"\xa9\xbd\xa0" +
	"L\x13\xd6!X\x07\xbb\xdeei\xfc\x99\xbe\xfb\xe3\xad" +
	"\xaf\xea4v\xd6\x1b\xeb\xd9\x80`\x03|\x0b\x00\x00\xff" +
	"\xff\x8a\xabR\xee"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_e945d32308a30635,
		Nodes: []uint64{
			0xa99b87f2a92d7eed,
		},
		Compressed: true,
	})
}
